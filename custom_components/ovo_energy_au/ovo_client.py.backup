"""
OVO Energy Australia API Client for Home Assistant

Simplified version of the main client for Home Assistant integration.
"""

import requests
import logging
import json
import hashlib
import secrets
import base64
from datetime import datetime
from typing import Dict, List, Any, Optional
from urllib.parse import urlparse, parse_qs, urlencode

_LOGGER = logging.getLogger(__name__)


# PKCE Helper Functions
def _generate_code_verifier() -> str:
    """Generate a code verifier for PKCE flow"""
    code_verifier = base64.urlsafe_b64encode(secrets.token_bytes(32)).decode('utf-8')
    return code_verifier.rstrip('=')


def _generate_code_challenge(code_verifier: str) -> str:
    """Generate a code challenge from the code verifier for PKCE flow"""
    code_challenge = hashlib.sha256(code_verifier.encode('utf-8')).digest()
    code_challenge = base64.urlsafe_b64encode(code_challenge).decode('utf-8')
    return code_challenge.rstrip('=')


class OVOAuthenticationError(Exception):
    """Raised when authentication fails"""
    pass


class OVOAPIError(Exception):
    """Raised when API requests fail"""
    pass


class OVOTokenExpiredError(Exception):
    """Raised when access tokens have expired"""
    pass


class OVOEnergyAU:
    """OVO Energy Australia API Client (Home Assistant version)"""

    API_URL = "https://my.ovoenergy.com.au/graphql"
    AUTH0_DOMAIN = "https://login.ovoenergy.com.au"
    CLIENT_ID = "5JHnPn71qgV3LmF3I3xX0KvfRBdROVhR"

    def __init__(self, access_token: Optional[str] = None,
                 id_token: Optional[str] = None,
                 account_id: Optional[str] = None,
                 refresh_token: Optional[str] = None,
                 token_update_callback=None):
        """Initialize the client

        Args:
            access_token: Access token (with Bearer prefix)
            id_token: ID token
            account_id: OVO account ID
            refresh_token: Refresh token for automatic token renewal
            token_update_callback: Callback function(access_token, id_token, refresh_token)
                                  called when tokens are refreshed
        """
        self._access_token = access_token
        self._id_token = id_token
        self._refresh_token = refresh_token
        self.account_id = account_id
        self._token_update_callback = token_update_callback

        self.session = requests.Session()
        self._update_session_headers()

    def _update_session_headers(self):
        """Update session headers with current tokens"""
        self.session.headers.update({
            'Content-Type': 'application/json',
            'Origin': 'https://my.ovoenergy.com.au',
            'Referer': 'https://my.ovoenergy.com.au/usage',
            'User-Agent': 'Mozilla/5.0 (Home Assistant)'
        })

        if self._access_token:
            self.session.headers['authorization'] = self._access_token
        if self._id_token:
            self.session.headers['myovo-id-token'] = self._id_token

    def set_tokens(self, access_token: str, id_token: str, refresh_token: Optional[str] = None):
        """Set authentication tokens"""
        self._access_token = access_token
        self._id_token = id_token
        if refresh_token:
            self._refresh_token = refresh_token
        self._update_session_headers()

    def authenticate(self, username: str, password: str) -> bool:
        """
        Authenticate with OVO Energy Australia using OAuth 2.0 PKCE flow

        This implements the full OAuth2 PKCE flow that OVO uses:
        1. Generate PKCE parameters
        2. Initial authorization request
        3. Submit credentials to login form
        4. Parse HTML form response
        5. Exchange code for tokens

        Args:
            username: OVO account email
            password: OVO account password

        Returns:
            True if authentication successful

        Raises:
            OVOAuthenticationError: If authentication fails
        """
        import re
        import html

        _LOGGER.info("Authenticating with OVO Energy using PKCE flow for user: %s", username)

        try:
            # Step 1: Generate PKCE parameters
            code_verifier = _generate_code_verifier()
            code_challenge = _generate_code_challenge(code_verifier)
            state = secrets.token_urlsafe(32)
            nonce = secrets.token_urlsafe(32)

            # Step 2: Initial authorization request
            auth_params = {
                "client_id": self.CLIENT_ID,
                "response_type": "code",
                "redirect_uri": "https://my.ovoenergy.com.au?login=oea",
                "scope": "openid profile email offline_access",
                "audience": "https://login.ovoenergy.com.au/api",
                "code_challenge": code_challenge,
                "code_challenge_method": "S256",
                "state": state,
                "nonce": nonce,
                "connection": "prod-myovo-auth"
            }

            auth_url = f"{self.AUTH0_DOMAIN}/authorize?" + urlencode(auth_params)

            session = requests.Session()
            response = session.get(auth_url, allow_redirects=False, timeout=30)

            # Extract state from response
            auth_state = None
            if response.status_code in [200, 302]:
                # Parse state from location or response
                if 'location' in response.headers:
                    parsed = urlparse(response.headers['location'])
                    query = parse_qs(parsed.query)
                    auth_state = query.get('state', [None])[0]

            if not auth_state:
                auth_state = state

            # Step 3: Submit credentials to login form
            login_payload = {
                "client_id": self.CLIENT_ID,
                "username": username,
                "password": password,
                "credential_type": "http://auth0.com/oauth/grant-type/password-realm",
                "realm": "prod-myovo-auth",
                "connection": "prod-myovo-auth",
                "state": auth_state
            }

            login_response = session.post(
                f"{self.AUTH0_DOMAIN}/usernamepassword/login",
                json=login_payload,
                headers={"Content-Type": "application/json"},
                timeout=30
            )

            _LOGGER.debug("Login response status: %s", login_response.status_code)

            if login_response.status_code != 200:
                _LOGGER.error("Login failed with status %s: %s",
                            login_response.status_code, login_response.text)
                raise OVOAuthenticationError(f"Login failed: {login_response.status_code}")

            # Step 4: Parse HTML form from response
            html_content = login_response.text

            # Extract form action URL
            form_action_match = re.search(r'<form[^>]*action="([^"]*)"', html_content)
            if not form_action_match:
                _LOGGER.error("Could not find form action in response")
                raise OVOAuthenticationError("Invalid response from login endpoint")

            form_action = html.unescape(form_action_match.group(1))

            # Extract all hidden input fields
            form_data = {}
            for match in re.finditer(r'<input[^>]*type="hidden"[^>]*name="([^"]*)"[^>]*value="([^"]*)"', html_content):
                field_name = html.unescape(match.group(1))
                field_value = html.unescape(match.group(2))
                form_data[field_name] = field_value

            _LOGGER.debug("Submitting form to: %s", form_action)

            # Step 5: Submit form and follow redirects to get authorization code
            form_response = session.post(
                form_action,
                data=form_data,
                allow_redirects=True,
                timeout=30
            )

            # Extract authorization code from final redirect URL
            auth_code = None
            for resp in [form_response] + list(getattr(form_response, 'history', [])):
                if "code=" in resp.url:
                    parsed = urlparse(resp.url)
                    query_params = parse_qs(parsed.query)
                    if "code" in query_params:
                        auth_code = query_params["code"][0]
                        break

            if not auth_code:
                _LOGGER.error("No authorization code found in OAuth flow")
                raise OVOAuthenticationError("Failed to obtain authorization code")

            _LOGGER.debug("Authorization code obtained, exchanging for tokens...")

            # Exchange code for tokens
            return self._exchange_code_for_tokens(auth_code, code_verifier)

        except OVOAuthenticationError:
            raise
        except Exception as e:
            _LOGGER.exception("Unexpected error during authentication: %s", e)
            raise OVOAuthenticationError(f"Authentication failed: {e}")

    def _auth_ropc(self, username: str, password: str) -> bool:
        """Try Resource Owner Password Credentials (ROPC) grant"""
        _LOGGER.debug("Trying ROPC grant")

        token_url = f"{self.AUTH0_DOMAIN}/oauth/token"

        payload = {
            "grant_type": "password",
            "username": username,
            "password": password,
            "client_id": self.CLIENT_ID,
            "scope": "openid profile email offline_access",
            "audience": "https://api.ovoenergy.com.au"
        }

        try:
            response = requests.post(
                token_url,
                json=payload,
                headers={"Content-Type": "application/json"},
                timeout=30
            )

            if response.status_code == 200:
                tokens = response.json()
                return self._process_tokens(tokens)

            _LOGGER.debug("ROPC failed with status %s: %s", response.status_code, response.text)
            return False

        except Exception as e:
            _LOGGER.debug("ROPC exception: %s", e)
            return False

    def _auth_password_realm(self, username: str, password: str) -> bool:
        """Try password realm grant (Auth0 specific)"""
        _LOGGER.debug("Trying password realm grant")

        token_url = f"{self.AUTH0_DOMAIN}/oauth/token"

        payload = {
            "grant_type": "http://auth0.com/oauth/grant-type/password-realm",
            "username": username,
            "password": password,
            "client_id": self.CLIENT_ID,
            "realm": "Username-Password-Authentication",
            "scope": "openid profile email offline_access"
        }

        try:
            response = requests.post(
                token_url,
                json=payload,
                headers={"Content-Type": "application/json"},
                timeout=30
            )

            if response.status_code == 200:
                tokens = response.json()
                return self._process_tokens(tokens)

            _LOGGER.debug("Password realm failed with status %s: %s", response.status_code, response.text)
            return False

        except Exception as e:
            _LOGGER.debug("Password realm exception: %s", e)
            return False

    def _auth_database_connection(self, username: str, password: str) -> bool:
        """Try Auth0 database connection login"""
        _LOGGER.debug("Trying database connection authentication")

        login_url = f"{self.AUTH0_DOMAIN}/usernamepassword/login"

        payload = {
            "client_id": self.CLIENT_ID,
            "username": username,
            "password": password,
            "credential_type": "http://auth0.com/oauth/grant-type/password-realm",
            "realm": "Username-Password-Authentication",
            "scope": "openid profile email offline_access"
        }

        try:
            session = requests.Session()
            response = session.post(
                login_url,
                json=payload,
                headers={
                    "Content-Type": "application/json",
                    "Auth0-Client": base64.b64encode(json.dumps({
                        "name": "auth0.js",
                        "version": "9.20.0"
                    }).encode()).decode()
                },
                timeout=30,
                allow_redirects=False
            )

            if response.status_code in [200, 302]:
                try:
                    data = response.json()
                    if "access_token" in data or "id_token" in data:
                        return self._process_tokens(data)
                except:
                    pass

                if response.status_code == 302 or "location" in response.headers:
                    location = response.headers.get("location", response.json().get("login_ticket"))
                    if location:
                        return self._complete_oauth_flow(session, location, username, password)

            _LOGGER.debug("Database connection failed with status %s", response.status_code)
            return False

        except Exception as e:
            _LOGGER.debug("Database connection exception: %s", e)
            return False

    def _complete_oauth_flow(self, session: requests.Session, state_or_ticket: str,
                            username: str, password: str) -> bool:
        """Complete the OAuth flow after initial login"""
        _LOGGER.debug("Attempting to complete OAuth flow")

        code_verifier = _generate_code_verifier()
        code_challenge = _generate_code_challenge(code_verifier)

        auth_params = {
            "client_id": self.CLIENT_ID,
            "response_type": "code",
            "redirect_uri": "https://my.ovoenergy.com.au/login/callback",
            "scope": "openid profile email offline_access",
            "code_challenge": code_challenge,
            "code_challenge_method": "S256",
            "state": secrets.token_urlsafe(32)
        }

        try:
            auth_url = f"{self.AUTH0_DOMAIN}/authorize?{urlencode(auth_params)}"
            response = session.get(auth_url, allow_redirects=True, timeout=30)

            for resp in [response] + list(getattr(response, 'history', [])):
                if "code=" in resp.url:
                    parsed = urlparse(resp.url)
                    query_params = parse_qs(parsed.query)
                    if "code" in query_params:
                        auth_code = query_params["code"][0]
                        return self._exchange_code_for_tokens(auth_code, code_verifier)

            _LOGGER.debug("No authorization code found in OAuth flow")
            return False

        except Exception as e:
            _LOGGER.debug("OAuth flow completion exception: %s", e)
            return False

    def _exchange_code_for_tokens(self, auth_code: str, code_verifier: str) -> bool:
        """Exchange authorization code for tokens"""
        _LOGGER.debug("Exchanging authorization code for tokens")

        token_url = f"{self.AUTH0_DOMAIN}/oauth/token"

        payload = {
            "grant_type": "authorization_code",
            "client_id": self.CLIENT_ID,
            "code": auth_code,
            "code_verifier": code_verifier,
            "redirect_uri": "https://my.ovoenergy.com.au/login/callback"
        }

        try:
            response = requests.post(
                token_url,
                json=payload,
                headers={"Content-Type": "application/json"},
                timeout=30
            )

            if response.status_code == 200:
                tokens = response.json()
                return self._process_tokens(tokens)

            _LOGGER.debug("Token exchange failed with status %s: %s", response.status_code, response.text)
            return False

        except Exception as e:
            _LOGGER.debug("Token exchange exception: %s", e)
            return False

    def _process_tokens(self, tokens: Dict[str, Any]) -> bool:
        """Process and store authentication tokens"""
        access_token = tokens.get("access_token")
        id_token = tokens.get("id_token")
        refresh_token = tokens.get("refresh_token")

        if not access_token or not id_token:
            _LOGGER.error("Missing required tokens in response")
            return False

        # Add "Bearer " prefix if not present
        if not access_token.startswith("Bearer "):
            access_token = f"Bearer {access_token}"

        self._access_token = access_token
        self._id_token = id_token
        self._refresh_token = refresh_token

        self._update_session_headers()

        # Try to extract account_id from ID token if not already set
        if not self.account_id:
            self.account_id = self._extract_account_id_from_token(id_token)

        _LOGGER.info("Tokens successfully processed and stored")
        return True

    def _extract_account_id_from_token(self, id_token: str) -> Optional[str]:
        """Attempt to extract account_id from ID token"""
        try:
            parts = id_token.split('.')
            if len(parts) != 3:
                return None

            payload = parts[1]
            padding = 4 - len(payload) % 4
            if padding != 4:
                payload += '=' * padding

            decoded = base64.urlsafe_b64decode(payload)
            payload_data = json.loads(decoded)

            for field in ['account_id', 'accountId', 'sub', 'user_id']:
                if field in payload_data:
                    value = str(payload_data[field])
                    if value.isdigit():
                        _LOGGER.info("Extracted account_id from token: %s", value)
                        return value

            _LOGGER.debug("Could not find account_id in ID token")
            return None

        except Exception as e:
            _LOGGER.debug("Failed to extract account_id from token: %s", e)
            return None

    def refresh_tokens(self) -> bool:
        """Refresh access and ID tokens using refresh token

        Returns:
            True if refresh was successful, False otherwise
        """
        if not self._refresh_token:
            _LOGGER.warning("No refresh token available, cannot refresh tokens")
            return False

        token_url = f"{self.AUTH0_DOMAIN}/oauth/token"

        payload = {
            "grant_type": "refresh_token",
            "client_id": self.CLIENT_ID,
            "refresh_token": self._refresh_token,
            "redirect_uri": "https://my.ovoenergy.com.au?login=oea"
        }

        try:
            _LOGGER.info("Refreshing tokens...")
            response = self.session.post(
                token_url,
                data=payload,  # URL-encoded form data
                headers={"Content-Type": "application/x-www-form-urlencoded"},
                timeout=30
            )

            _LOGGER.debug("Token refresh response status: %s", response.status_code)

            if response.status_code != 200:
                _LOGGER.error("Token refresh failed with status %s: %s",
                            response.status_code, response.text)
                return False

            token_data = response.json()
            _LOGGER.debug("Token refresh response data keys: %s", token_data.keys())

            # Extract new tokens
            new_access_token = token_data.get("access_token")
            new_id_token = token_data.get("id_token")
            new_refresh_token = token_data.get("refresh_token")

            if not new_access_token or not new_id_token:
                _LOGGER.error("Token refresh response missing tokens")
                return False

            # Add "Bearer " prefix if not present
            if not new_access_token.startswith("Bearer "):
                new_access_token = f"Bearer {new_access_token}"

            # Update tokens
            self._access_token = new_access_token
            self._id_token = new_id_token
            if new_refresh_token:
                self._refresh_token = new_refresh_token

            self._update_session_headers()

            # Notify callback if set
            if self._token_update_callback:
                _LOGGER.info("Calling token update callback to persist new tokens")
                self._token_update_callback(
                    new_access_token,
                    new_id_token,
                    new_refresh_token or self._refresh_token
                )

            _LOGGER.info("Successfully refreshed tokens")
            return True

        except Exception as e:
            _LOGGER.exception("Error refreshing tokens: %s", e)
            return False

    def _make_graphql_request(self, query: str, variables: Dict[str, Any], retry_on_401: bool = True) -> Dict[str, Any]:
        """Make a GraphQL request

        Args:
            query: GraphQL query string
            variables: Query variables
            retry_on_401: If True, automatically retry with token refresh on 401 errors

        Returns:
            GraphQL response data
        """
        if not self._access_token or not self._id_token:
            raise OVOAuthenticationError("Not authenticated")

        payload = {
            "query": query,
            "variables": variables
        }

        try:
            response = self.session.post(
                self.API_URL,
                json=payload,
                timeout=30
            )

            if response.status_code == 401:
                # Try to refresh tokens and retry once
                if retry_on_401 and self._refresh_token:
                    _LOGGER.info("Received 401, attempting token refresh...")
                    if self.refresh_tokens():
                        _LOGGER.info("Token refresh successful, retrying request...")
                        return self._make_graphql_request(query, variables, retry_on_401=False)
                    else:
                        _LOGGER.error("Token refresh failed")

                raise OVOTokenExpiredError("Access tokens expired and refresh failed")

            if response.status_code != 200:
                raise OVOAPIError(
                    f"API request failed with status {response.status_code}"
                )

            result = response.json()

            if "errors" in result:
                error_msg = "; ".join([e.get("message", str(e)) for e in result["errors"]])
                raise OVOAPIError(f"GraphQL errors: {error_msg}")

            return result.get("data", {})

        except requests.RequestException as e:
            raise OVOAPIError(f"Network error: {e}")

    def get_today_data(self) -> Dict[str, List[Dict]]:
        """Get today's hourly energy data"""
        if not self.account_id:
            raise ValueError("account_id must be set")

        today = datetime.now().strftime("%Y-%m-%d")

        query = """
        query GetHourlyData($input: GetHourlyDataInput!) {
          GetHourlyData(input: $input) {
            solar {
              periodFrom
              periodTo
              consumption
              readType
              charge {
                value
                type
              }
            }
            export {
              periodFrom
              periodTo
              consumption
              readType
              charge {
                value
                type
              }
              rates {
                type
                charge {
                  value
                  type
                }
                consumption
                percentOfTotal
              }
            }
            savings {
              periodFrom
              periodTo
              amount {
                value
                type
              }
              description
            }
          }
        }
        """

        variables = {
            "input": {
                "accountId": self.account_id,
                "dateRange": {
                    "startDate": today,
                    "endDate": today
                }
            }
        }

        result = self._make_graphql_request(query, variables)
        return result.get("GetHourlyData", {})

    def get_interval_data(self) -> Dict[str, Any]:
        """Get daily/monthly/yearly interval data

        Returns aggregated data for daily, monthly, and yearly periods.
        Useful for getting month-to-date and historical monthly totals.
        """
        if not self.account_id:
            raise ValueError("account_id must be set")

        query = """
        query GetIntervalData($input: GetIntervalDataInput!) {
          GetIntervalData(input: $input) {
            daily {
              solar {
                periodFrom
                periodTo
                consumption
                readType
                charge {
                  value
                  type
                }
              }
              export {
                periodFrom
                periodTo
                consumption
                readType
                charge {
                  value
                  type
                }
                rates {
                  type
                  charge {
                    value
                    type
                  }
                  consumption
                  percentOfTotal
                }
              }
              savings {
                periodFrom
                periodTo
                amount {
                  value
                  type
                }
                description
              }
            }
            monthly {
              solar {
                periodFrom
                periodTo
                consumption
                readType
                charge {
                  value
                  type
                }
              }
              export {
                periodFrom
                periodTo
                consumption
                readType
                charge {
                  value
                  type
                }
                rates {
                  type
                  charge {
                    value
                    type
                  }
                  consumption
                  percentOfTotal
                }
              }
              savings {
                periodFrom
                periodTo
                amount {
                  value
                  type
                }
                description
              }
            }
            yearly {
              solar {
                periodFrom
                periodTo
                consumption
                readType
                charge {
                  value
                  type
                }
              }
              export {
                periodFrom
                periodTo
                consumption
                readType
                charge {
                  value
                  type
                }
                rates {
                  type
                  charge {
                    value
                    type
                  }
                  consumption
                  percentOfTotal
                }
              }
              savings {
                periodFrom
                periodTo
                amount {
                  value
                  type
                }
                description
              }
            }
          }
        }
        """

        variables = {
            "input": {
                "accountId": self.account_id
            }
        }

        result = self._make_graphql_request(query, variables)
        return result.get("GetIntervalData", {})

    def close(self):
        """Clean up resources"""
        self.session.close()
